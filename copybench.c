#define _POSIX_C_SOURCE 199309L
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "copy_functions.h"

// Function to measure execution time and perform copy
void benchmark_copy(char *src, char *dst, unsigned int buf_size, int use_buffered) {
    struct timespec start, finish;
    double elapsed_ms;
    int bytes_copied;
    
    // Start timing
    clock_gettime(CLOCK_MONOTONIC, &start);
    
    // Perform copy based on the method
    if (use_buffered) {
        bytes_copied = copyf(src, dst, buf_size);
    } else {
        bytes_copied = copy(src, dst, buf_size);
    }
    
    // End timing
    clock_gettime(CLOCK_MONOTONIC, &finish);
    
    // Calculate elapsed time in milliseconds
    elapsed_ms = (finish.tv_sec - start.tv_sec) * 1000.0;
    elapsed_ms += (finish.tv_nsec - start.tv_nsec) / 1000000.0;
    
    // Check if copy was successful
    if (bytes_copied < 0) {
        fprintf(stderr, "Error during copy operation\n");
        return;
    }
    
    // Print results
    printf("Copied (%s) \"%s\" into \"%s\" (%dKB in chunks of %d bytes) in %.1f ms\n",
           use_buffered ? "fread/fwrite" : "read/write",
           src,
           dst,
           bytes_copied / 1024,
           buf_size,
           elapsed_ms);
}

int main(int argc, char *argv[]) {
    const unsigned int SMALL_BUF = 1;          // 1 byte buffer
    const unsigned int LARGE_BUF = 32 * 1024;  // 32KB buffer
    
    // Check command line arguments
    if (argc != 3) {
        fprintf(stderr, "Usage: %s SRC DST\n", argv[0]);
        return 1;
    }
    
    // Perform all four copy operations
    
    // 1. read/write with 1-byte buffer
    benchmark_copy(argv[1], argv[2], SMALL_BUF, 0);
    
    // 2. fread/fwrite with 1-byte buffer
    benchmark_copy(argv[1], argv[2], SMALL_BUF, 1);
    
    // 3. read/write with 32KB buffer
    benchmark_copy(argv[1], argv[2], LARGE_BUF, 0);
    
    // 4. fread/fwrite with 32KB buffer
    benchmark_copy(argv[1], argv[2], LARGE_BUF, 1);
    
    return 0;
}